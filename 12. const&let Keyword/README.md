
# var 키워드의 문제점

<br>

1. `변수 중복 선언 허용`<br>
   동일한 이름의 변수가 이미 선언되어 있는 것을 모르고 변수를 중복 선언하면서 값까지 할당했다면<br>
   의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 발생한다.<br>
<br>

2. `함수 레벨 스코프`<br>
   var로 선언한 변수는 오로지 함수의 코드 블록만을 지역스코프로 인정한다.<br>
   따라서, 함수 외부에서 선언한 변수는 모두 전역변수가 된다.<br>
<br>

3. `변수 호이스팅`<br>
   var로 선언한 변수는 호이스팅에 의해 선언문이 최상단으로 올려진 것처럼 동작하여 에러를 발생시키지 않고<br>
   의도치 않은 undefined값을 뱉는다.<br>
<br>


## let 키워드

<br>

ES6에서 새롭게 나온 키워드로 다음과 같은 특징이 있다.<br>
<br>

1. 변수 중복선언 금지<br>
2. 블록 레벨 스코프 (`if`, `for`, `while`)과 같은 블록의 지역스코프를 인정한다.<br>
3. 변수 `호이스팅`이 발생하지 않는 것처럼 동작한다.<br>

> var 변수는 `호이스팅`과 더불어 `undefined`로 값이 초기화되어 에러없이 사용 가능하지만 let으로 선언한 변수는 선언과 초기화 단계가 > `나뉘어` 실행된다. 따라서, 선언만 동작 후 초기화는 선언문에 `도달`해야만 할당된다. 때문에, 할당문 전에 let으로 선언한 변수를 호출하> 면 `참조에러`를 발생시킨다.


## const 키워드

<br>

const 키워드도 마찬가지로 ES6에 추가되었고 상수를 선언하기 위해 사용하지만 꼭 상수만을 위해 사용하는 것은 아니다.<br>
const 키워드의 특징은 대부분 let과 `동일`하다.<br>

<br>

### let 과 const의 다른 점

<br>

1. `선언과 초기화` <br>
   const 키워드로 선언한 변수는 반드시 `선언과 동시에 초기화`해야한다.<br>
<br>

```JavaScript
var foo = 1; // good

var foo; // SystaxError
```

<br>

2. `재할당 금지` <br>
   상수에 선언된 `원시값[변경 불가능한 값]`은 값을 바꿔야 할 경우 `재할당`을 통해 변경해야한다. 하지만 const는 재할당이 `불가`하기 때문에 원시값의 값을 바꿀 수 없다.

<br>

3. `const와 객체` <br>
   방금 위에서 `원시값[변경 불가능한 값]`은 변경 불가능하다 했지만, `객체[변경 가능한 값]`은 값을 변경할 수 있다.<br>
   객체는 재할당 없이도 값을 변경할 수 있기 때문이다.<br>

<br>

```JavaScript
const Person = {
  name : 'kim'
};

Person.name = 'Lee'
```

<hr>

> 변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다.





