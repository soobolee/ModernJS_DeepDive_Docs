
# 변수

## 변수란

`변수`는 2진수의 값을 저장하기 위해 확보한 메모리 공간에 자체를 뜻하며, 메모리 공간을 식별하기 위해 붙인 이름이다.
```JavaScript
var score = 10 + 20;
```
score 는 메모리 공간에 저장된 값을 식별하는 고유이름
score 에 저장된 30이라는 값을 변수값이라 한다.
변수에 값을 저장하는 것을 `할당`(대입, 저장)
변수의 값을 읽어들이는 것을 `참조`라한다.

> 코드를 읽는 사람은 변수명을 보고 변수에 저장된 값의 의미를 명확히 할 수 있다.
따라서, 좋은 변수 네이밍은 코드의 가독성을 높이고 협업과, 품질향상에 도움을 준다.

--------

## 식별자

`식별자`는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다, 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별 할 수 있어야 한다. 이를 위해 식별자는 메모리 주소를 기억한다.
```JavaScript
var score = 10 + 20;
```
위애서 적었다 싶이 식별자는 위 예제에서 값 30이 저장되어 있는 메모리 주소를 기억하기 위해 메모리 주소와 매핑된 정보 메모리 주소[ex:0x0669F913]을 저장해야한다.
 > JS는 변수, 함수, 클래스등의 이름은 모두 식별자이다.
따라서, 식별자는 네이밍 규칙을 준수해야하고, 선언에 의해 JS엔진에 식별자의 존재를 알린다.

--------

## 변수 선언

변수 선언은 메로리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.
변수를 사용하려면 반드시 선언이 필요하고, 선언 시에는 `var`, `let`, `const` 키워드를 사용한다.
`let, const는 ES6` 이후 도입되었다.
```JavaScript
var score;
```
위에서 값을 할당하지 않은 변수를 선언하였다. 따라서 변수의 빈공간이 있다 생각하겠지만 빈공간보다는 `JS엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화된다.`

> 변수선언은 선언, 초기화 단계를 거친다.
> `1. 선언 단계` : 변수 이름을 JS엔진에 알린다.
> `2. 초기화 단계` : 값을 저장하기 위해 메모리 공간을 확보하고, 값이 없다면 undefined로 초기화한다.

만약 선언 단계를 수행하지 않는다면, 선언하지 않은 식별자에 접근하기 때문에 `접근에러`[Reference Error]가 발생한다.
만약 초기화 단계를 수행하지 않는다면, 기존 메모리에 할당되어 있는 `값[Garbage Variable]` 이 나올 수 있어 런타임 에러에 조심해야 한다.

즉 위 예제는 이러한 위험을 막기 위해 변수 선언 시 선언단계/초기화단계가 동시에 이루어진다.

--------

## 변수 선언의 실행 시점과 변수 호이스팅

`변수 호이스팅`은 변수 선언문이 코드이 상단으로 끌어올려진 것처럼 동작하는 JS만의 고유 특징이다.
```JavaScript
console.log(result);
var result;
```
변수 선언파트를 봤다면 해당코드는 참조에러가 발생할 것만 같지만, console에는 undefined가 출력된다.
그 이유는, 변수선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.

JS는 한 줄씩 실행되기 이전 소스코드의 평가과정을 거치는데 이때 변수를 포함한 모든 선언문을 찾아내 먼저 실행한다.
즉, 변수선언이 소소코드 어디에 있던 상관없이 변수를 참조할 수는 있다.

또한 변수뿐 아니라 `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용하는 식별자는 모두 호이스팅 된다.
모든 선언문은 런타임 이전 단계에서 실행되기 때문이다.

--------

## 변수의 할당, 재할당

변수의 값을 할당하는 것을 `할당`, 새로운 값을 다시 할당하는 것을 `재할당`이라고 한다.
```JavaScript
var result;
result = 80;
result = 90;
```
위 예제에서 var로 변수를 선언하며 자동으로 undefined가 할당되어 지기 때문에 2번째 줄에서는 재할당이 이루어진 것이다.
할당 
과정을 적자면
> undefined -> 80 -> 90
총 3번의 할당을 했는데, undefined, 80을 메모리상에서 지우고 90이란 값을 재할당 한 것이 아닌 `새로운 메모리공간!` 을 확보하여 값을 저장했다.
>> `가비지 콜렉터 [Garbage Collector]`<br>
>> 위 상황 같이 재할당을 통해 메모리 주소값이 매핑된 식별자를 잃어버린 쓰레기값 들은 `가비지콜렉터`에 의해 메모리에서 자동 해재된다. 그러나 `언제` 메모리 할당이 풀릴지는 알 수 없다.


--------

### 네이밍 규칙

1. 식별자는 특수문자를 제외한 `문자`, `숫자`, `언더바`, `달러`를 사용할 수 있다.
2. 단, 식별자는 특수문자를 제외한 `문자`, `언더바`, `달러`로 시작해야한다.
3. `예약어`는 식별자로 사용할 수 없다.

```JavaScript
var camelCase; // 카멜 케이스

var snake_case; // 스네이크 케이스

var PaskcalCase; // 파스칼 케이스

var strFirstMan; // 헝가리안 케이스
var #elem = document.getElementById("myId");
var observerabl& = fromEvent(document, "click");
```
위 처럼 JS에는 다양한 케이스가 있지만 일반적으로
 - 변수, 함수에는 `카멜케이스`
 - 생성자, 클래스에는 `파스칼케이스`
 
를 주로 사용한다.

--------

## 예제해석

- 예제 4-10
```JavaScript
console.log(score);

score = 80;
var score;

console.log(score);
```

- 출력순서 
undefined -> 80

- 추측
1. JS가 런타입하기 전 평가과정을 거치며 변수선언문은 호이스팅을 통해 먼저 실행된다.
2. 호이스팅 덕분에 참조에러가 아닌 undefined를 뱉는다.
3. score은 먼저 선언되어 있기 때문에 80이 할당된다.
4. undefined에서 새로운 메모리 공간을 확보해 할당된 80이 뱉어진다.

