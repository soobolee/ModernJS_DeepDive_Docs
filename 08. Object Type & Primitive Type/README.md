
# 원시 타입과 객체 타입의 비교

자바스크립트는 크게 `원시타입`과 `객체타입`으로 구분한다. 그렇다면, 그 이유는 무엇일까?<br />
<br />
원시타입과 객체타입을 나누는 이유는 크게 세가지 측면이 있다.<br />
<br />
1. 원시타입은 `변경불가능`한 값이고, 객체타입은 `변경가능`한 값이다.<br />
2. 원시값을 변수에 할당하면 `실제 값`이 저장된다. 객체타입은 `참조 값`이 저장된다.<br />
3. 기존 변수에 원시값을 재할당하면 `새로운 원시값`이 복사되어 전달되고, 객체타입은 원본의 `참조값`이 복사되어 전돨된다.<br />

<hr />

## 원시 값
- 변경 불가능한 값<br />
<br />

원시타입은 변경 불가능한 원시 값을 가진다. 즉, 한 번 생성한 후 변경이 `불가능`해진다.<br />
하지만 우리는 Number타입의 값을 수도 없이 많이 바꿔왔다. 즉, 여기서 변경 불가능하다고 칭하는 것은 변수가 아닌 `값`을 이야기 한다.<br />
<br />
변수는 재할당을 하면 기존 메모리 주소의 값을 바꾸는 것이 아닌 새로운 매모리 공간을 확보 후 값을 할당하여 변수가 참조하는 메모리 주소 자체를 변경한다.<br />
<br />

> 그렇기 때문에 한 번 저장한 값은 바뀌지 않는다는 점에서 데이터의 `신뢰성`을 보장하고 이 특성을 `불변성`이라 한다.

```JavaScript
var str = 'string';

console.log(str[0]); // s

console.log(str.length);
console.log(str.toUpperCase());
```

<br />

위 예제를 보면 문자열을 객체 사용하듯이 내장 메서드를 꺼내 쓰고 있다.<br />
하지만 이는 문자열이 `유사 배열 객체` 이기 때문이지 문자열이 사실은 객체이기 때문은 아니다.<br />
<br />
위 상황은 <br />

- 21절에서 다시 한 번 보겠지만 요약하자면 원시 값을 객체처럼 사용하면 `래퍼 객체`로 자동 변환되었다가 `다시 원시값`으로 돌아오기 때문이다.<br />
<br />
즉 문자열은 위에서 객체 처럼 보인다하여 <br />
<br />

```JavaScript
str[0] = 't';

console.log(str) // string
```
와 같은 상황은 벌어질 수 없다. 문자열은 원시값이기 때문이다. [재할당은 가능]

<hr />

## 값에 의한 전달

메모리 주소가 아닌 값을 전달하고 복사한다는 점에서 `깊은복사`라고 하기도 한다.

```JavaScript
var str = 80;
var copy = str;
```

<br />
위 예제와 같이 값의 의한 전달이 발생한다면, str변수 원시값이 복사되어 copy변수에 저장된다.<br />
또한 copy변수를 변경하든 str변수를 변경하든 두 변수 사이에 영향은 없다.<br />
즉, 복사가 이루어지면 두 변수의 관계성은 0이 된다.<br />
<br />

> 사실은 값의 전달이라기 보단 메모리 주소의 전달이 맞는 표현이지만 주소 전달은 오해를 불러 일으킬 소지가 있다.

<br />
위 원리로 추정되는 것은 두 가지가 있다.<br />
- 새로운 원시값을 복사해서 메모리 주소를 전달하는 방식<br />
- 기존 변수의 메모리 주소를 그대로 전달 후 둘 중 한 변수에게 재할당 시 메모리 주소를 분리<br />

<hr />

## 객체

객체는 프로퍼티의 수가 정해지지 않았고, 동적으로 추가, 생성, 삭제 할 수 있다. 때문에, 메모리 공간의 크기를 사전에 정해둘 수 없다.<br />
따라서 객체의 크기는 굉장히 클 수 있고, 성능 면에서 좋지 않을 수 있다.<br />
<br />
`hiddenClass`
- 런타임 이후에도 동적으로 추가될 수 있는 객체를 자바의 객체처럼 고정된 객체처럼 작동하게 만든다.<br />
- 객체에 속성이 변경될 때마다 클래스전환을 실시하여 `새로운` 히든클래스를 생성합니다.<br />
- 객체 변동에 대한 순서를 기억하고 있기 때문에 새로운 객체가 생성 시 해당 객체의 순서에 맞는 히든클래스를 사용합니다.<br />
- 각 히든클래스에는 정적인 offset이 저장되며 속성의 위치 정보를 기억할 일이 사라집니다.<br />
<br />

> 자바스크립트는 이러한 문제를 엔진에서 히든 클래스라는 방식을 사용해 해소하였다.

<hr />

## 변경 가능한 값

객체타입은 변경 `가능`한 값이다. <br />
객체는 원시값처럼 `재할당 없이` 객체를 직접 변경할 수 있다.<br />
원시값에서는 재할당을 위해서 새로운 메모리 공간을 확보해야했지만 객체는 기존 공간을 활용한다. 이는 메모리사용의 효율성과 성능을 향상시킨다.<br />
<br />

```JavaScript
var obj = {};
obj.name = 'leesoobo';
```

<br />
기존 메모리에 name프로퍼티가 추가된다.<br />

<hr />

## 참조에 의한 전달

하지만 이러한 장점의 `단점`으로는 여러 식별자가 하나의 객체 주소를 `공유`할 수 있다는 것이다.<br />
이를 흔히 `얕은 복사`라고 부르기도 하는데<br />
값을 직접 복사해서 전달하는 원시 값과 다르게 객체는 메모리 주소를 공유한다.<br />
<br />

```JavaScript
var person = {
 name: 'Lee'
};
// 참조 값을 복사（얕은 복사）
var copy = person;

copy.age = 29;

console.log(person); // name : lee, age : 29
console.log(copy);   // name : lee, age : 29
```

<br />

위 예제처럼 참조에 의한 전달이 발생하면 person, copy 객체는 서로 같은 메모리 주소를 공유한다. 따라서 두 객체는 같은 객체를 바라보게 된다.<br />
즉, 어느 하나의 프로퍼티를 변경하면 같을 복사한 복사체나 원본이나 `둘 다 영향`을 받는다.<br />



