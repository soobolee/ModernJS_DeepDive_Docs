
# 실행 컨텍스트

<br>
- 실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체.<br>
- JS의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념<br><br>

JS는 동일한 환경에 있는 환경 정보들을 모은 실행 컨텍스트를 `콜스택`에 쌓아올린 후 실행하여 코드의 환경과 순서를 보장할 수 있게 됩니다.
<br>

> 콜 스택 -> 스택[Stack]<br>
> 은 하나의 자료구조로 `LIFO[Last-In-First-out]` -> 나중에 들어온 것이 먼저 밖으로 나간다는 자료구조다.<br><br>

즉, 실행 컨텍스트는 삭별자를 등록하고 관리하는 스코프와 코드 실행 순서관리를 구현한 내부 매커니즘으로, 실행 컨텍스트는 곧 자바스크립트의 `핵심 원리`다.<br><br>

## 소스코드의 타입 4가지

<br>

1. 전역코드<br>
   전역코드는 전역변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다. var 키워드로 선언된 전역변수와 전역 스코프를 가지는
   함수선언문은 전역객체의 프로퍼티와 메서드로 바인딩 되어야 한다.<br>
   이를 위해 전역코드가 평가되면 전역 실행 컨텍스트가 생성된다.<br><br>

2. 함수코드<br>
   함수코드는 지역 스코프를 생성하고, 지역변수, 매개변수, arguments객체를 관리해야 한다.<br>
   그리고 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다.<br><br>

3. eval코드<br>
   eval코든느 strict모드에서 자신만의 독자적인 스코프를 생성한다. 이를 위해 eval코드가 평가되면 eval실행 컨텍스트가 생성된다.<br><br>

4. 모듈코드<br>
   모듈 별로 독립적인 모듈 스코프를 생성한다. 이를 위해 모듈 실행 컨텍스트가 생성된다.<br><br>

## 소스코드의 평가와 실행

<br>

모든 소스코드는 실행에 앞서 평가 과정을 거치며 코드를 실행하기 위한 준비를 한다. <br>
즉, 소스코드의 평가 소스코드의 실행으로 나누어 처리한다.<br><br>

1. `소스코드의 평가`<br>
   실행 컨텍스트를 생성하고 변수, 함수등의 선언문만 먼저 실행하여<br>
   생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록한다.<br>

2. `소스코드의 실행`<br>
   평가 과정이 종료 후 선언문을 제외한 소스코드가 순차적으로 실행된다, 즉 런타임<br>
   이때 런타임 중에 필요한 정보[변수나 함수의 참조]가 필요하면 등록된 실행컨텍스트의 스코프에서 검색한다.<br><br>

```JavaScript
var x;
x = 1;
```

- 코드 실행 순서<br>
  1. 먼저 소스코드 평가를 거치며 변수 선언문이 var x;를 먼저 실행한다.<br>
  2. 생성된 변수식별자는 실행 컨텍스트가 관리하는 스코프에 등록된다.<br>
  3. 등록된 변수는 undefined로 초기화 된다.<br>
  4. 런타임이 되고, 변수 할당문에 도착하면<br>
  5. 변수 x가 선언된 변수인지 확인을 위해 실행컨텍스트가 관리하는 스코프에 접근<br>
  6. x는 전역 실행컨텍스트가 관리하는 전역스코프에서 찾을 수 있으니 값 1을 할당한다.<br><br>

## 실행 컨텍스트의 순서

<br>

1. 전역 코드 평가 <br>
2. 전역 코드 실행<br>
3. 함수 코드 평가<br>
   함수 호출에 의해 실행 순서가 변경돠어 함수 내부로 들어왔을 시 함수 내부 코드의 평가후 실행함<br>
4. 함수 코드 실행<br><br>

## 실행 컨텍스트의 생성과 작동 과정

<br>

```JavaScript
const x = 1;

function foo () {
  const y = 2;

  function bar () {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```

> 전역 코드를 평가하여 `전역 실행 컨텍스트를` 생성한다.
> 함수가 호출되면 함수코드를 평가하여 `함수 실행 컨텍스트`를 생성한다.
> > 이때 생성된 실행 컨텍스트는 `스택` 자료구조로 관리된다.
>
> 1.  전역 코드 x foo 를 평가하며 전역 실행 컨텍스트를 생성하고 콜 스택에 `푸시`한다.
> 2.  코드가 실행되며 x에 값이 `할당`되고, foo함수가 `호출`된다.
> 3.  전역코드의 실행은 중단되고, foo함수 내부로 이동하여 코드를 평가하고 콜 스택에 `푸시`한다.
> 4.  이후 함수 내부 코드는 실행되며, foo함수 실행 컨텍스트에 있는 y에 값이 `할당`되고 bar함수 `실행`된다.
> 5.  foo함수 실행은 중단되고, bar 내부로 이동하여 `bar 실행 컨텍스트 생성`
> 6.  bar 내부 코드는 평가되며 콜 스택에 `푸시`한다.
> 7.  bar 내부 코드가 실행되며 z 변수에 값을 `할당`하고, console.log()를 실행 후 bar함수는 `종료`된다.
> 8.  foo함수로 복귀하여 실행 컨텍스트 스택에서 bar함수를 팝하여 `제거`한다.
> 9.  전역코드로 복귀하여 실행 컨텍스트 스택에서 foo함수를 팝하여 `제거`한다.
> 10. 전역코드에서는 더 이상 실행할 코드가 없으므로 전역 실행 컨텍스트 또한 실행 컨텍스트 스택에서 팝하여 `제거`한다.
> 11. 이후 소스코드는 `종료`된다.

<br>

## 블록 레벨 컨텍스트

함수 블록 단위인 var와 다르게 `let`, `const`는 `블록 레벨의 스코프`를 가진다.<br>
따라서, if블록에 대해 새롭게 `렉시컬 환경`과 `블록 레벨 스코프`를 생성하여 변수를 관리한다.<br>
for문의 경우 반복 때마다 `독립적`인 렉시컬 환경을 생성하여 식별자의 값을 `유지`한다. <br>

<br>

## 렉시컬 환경

<a href="https://kwangsunny.tistory.com/37">렉시컬 환경에 대해 이해하기 쉽고 자세하게 기술되어 있는 좋은 블로그 추천</a>
